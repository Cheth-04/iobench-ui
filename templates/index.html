<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IOBench Manager</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --border-color: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent-blue: #3b82f6;
            --accent-purple: #8b5cf6;
            --success: #10b981;
            --danger: #ef4444;
            --gradient-primary: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Navbar */
        .navbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 30px;
            padding: 15px 25px;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid var(--border-color);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .brand span {
            background: var(--gradient-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .navbar-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn-stop {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .btn-stop:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        /* Buttons & Inputs */
        button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.5);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 8px -1px rgba(59, 130, 246, 0.6);
        }

        .btn-primary:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: #334155;
            color: white;
            border: 1px solid #475569;
        }

        .btn-secondary:hover {
            background: #475569;
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            border: 1px solid rgba(239, 68, 68, 0.2);
            padding: 8px 12px;
            font-size: 0.85em;
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .btn-sm {
            padding: 6px 10px;
            font-size: 0.85em;
        }

        select,
        input {
            padding: 10px 12px;
            background: #0f172a;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: white;
            font-family: inherit;
            box-sizing: border-box;
            width: 100%;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #1a1f2e;
        }

        /* Toggles */
        .toggle-container {
            display: flex;
            gap: 5px;
            background: #0f172a;
            padding: 4px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .toggle-btn {
            background: transparent;
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85em;
        }

        .toggle-btn.active {
            background: #334155;
            color: white;
            font-weight: 600;
        }

        /* Worker Cards */
        .worker-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .worker-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
        }

        .worker-card.idle {
            border-left: 4px solid var(--text-secondary);
        }

        .worker-card.running {
            border-left: 4px solid var(--success);
        }

        .worker-card.error {
            border-left: 4px solid var(--danger);
        }

        .worker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

        .worker-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .status-text {
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .status-text.running {
            color: var(--success);
        }

        /* Target Cards */
        .targets-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .target-card {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
        }

        .target-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .target-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
        }

        .target-config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .config-item label {
            display: block;
            font-size: 0.7em;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 6px;
            font-weight: 600;
        }

        /* Charts */
        .worker-charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .worker-chart-box {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .chart-header {
            margin-bottom: 12px;
        }

        .chart-title {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
        }

        .chart-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 3px;
        }

        /* Final Output Section */
        .final-output-section {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .output-header {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .metrics-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }

        .metric-item {
            font-size: 0.85em;
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.85em;
        }

        .metric-value {
            font-weight: 600;
            font-size: 1.1em;
            margin-top: 3px;
        }

        .download-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .raw-output-box {
            margin-top: 10px;
        }

        .raw-output-toggle {
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 0.85em;
            margin-bottom: 8px;
            user-select: none;
        }

        .raw-output-toggle:hover {
            text-decoration: underline;
        }

        .raw-output-content {
            display: none;
            max-height: 200px;
            overflow-y: auto;
            background: #0f172a;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            color: #cbd5e1;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .raw-output-content.open {
            display: block;
        }

        /* Logs */
        .log-section {
            margin-top: 30px;
            background: #0f172a;
            border-top: 1px solid var(--border-color);
            padding: 10px;
        }

        .log-header {
            padding: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }

        #logContainer {
            height: 150px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: #cbd5e1;
            display: none;
            padding: 10px;
        }

        #logContainer.open {
            display: block;
        }

        .log-line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            transform: translateX(200%);
            transition: transform 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }
    </style>
</head>

<body>

    <div class="container">

        <!-- Navbar -->
        <nav class="navbar">
            <div class="brand">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="url(#logoGradient)"
                    stroke-width="2">
                    <defs>
                        <linearGradient id="logoGradient" x1="0" y1="0" x2="1" y2="1">
                            <stop offset="0%" stop-color="#3b82f6" />
                            <stop offset="100%" stop-color="#8b5cf6" />
                        </linearGradient>
                    </defs>
                    <path d="M22 12h-4l-3 9L9 3l-3 9H2" />
                </svg>
                <span>IOBench Manager</span>
            </div>
            <div class="navbar-controls">
                <button class="btn-secondary" onclick="resetApp()">‚ü≥ Reset</button>

                <div
                    style="display: flex; align-items: center; background: rgba(30, 41, 59, 0.5); border-radius: 6px; padding: 2px; border: 1px solid var(--border-color);">
                    <div style="font-size: 0.8em; margin: 0 8px; color: var(--text-secondary);">Multi-Worker</div>
                    <button id="modeSingle" class="toggle-btn active" onclick="setMultiWorker(false)">Off</button>
                    <button id="modeMulti" class="toggle-btn" onclick="setMultiWorker(true)">On</button>
                </div>

                <div id="execModeContainer" style="display:none; align-items:center; gap:8px;">
                    <div class="toggle-container">
                        <button class="toggle-btn active" id="execPar"
                            onclick="setExecutionMode('parallel')">Parallel</button>
                        <button class="toggle-btn" id="execSeq"
                            onclick="setExecutionMode('sequential')">Sequential</button>
                    </div>
                </div>

                <div style="width:1px; background:var(--border-color); margin:0 5px;"></div>

                <button class="btn-secondary" id="btnAddWorker" onclick="addNewWorker()" style="display:none;">+ Add
                    Worker</button>
                <button class="btn-stop" onclick="abortJob()" id="btnStop" style="display:none;">‚èπ Stop</button>
                <button class="btn-primary" onclick="runJob()" id="btnRun">‚ñ∂ Run</button>
            </div>
        </nav>

        <!-- Workers List -->
        <div class="worker-list" id="workerList"></div>
    </div>

    <!-- Logs -->
    <div style="position:fixed; bottom:0; left:0; width:100%; z-index:900;">
        <div class="log-section">
            <div class="log-header" onclick="document.getElementById('logContainer').classList.toggle('open')">
                <span>>_ System Activity Log</span>
                <span>^</span>
            </div>
            <div id="logContainer"></div>
        </div>
    </div>

    <div id="toast" class="toast">
        <div id="toastMsg"></div>
    </div>

    <!-- Devices Data -->
    <script>
        const AVAILABLE_DEVICES = {{ devices | tojson }};
    </script>

    <script>
        // State - RESTRUCTURED for per-target configuration
        let state = {
            multiWorker: false,
            executionMode: 'parallel',
            workers: [],
            currentJobId: null, // To store the ID of the currently running job
            eventSource: null // To store the EventSource object
        };

        // --- Initialization ---

        function init() {
            // Default: One worker with one empty target
            addNewWorker(true);
            renderUI();
        }

        function setMultiWorker(enable) {
            if (!enable && state.workers.length > 1) {
                if (!confirm("Disabling Multi-Worker mode will remove extra workers. Continue?")) return;
                state.workers = [state.workers[0]]; // Keep first
            }

            state.multiWorker = enable;

            if (enable && state.workers.length === 1) {
                addNewWorker();
            }

            renderUI();
        }

        function setExecutionMode(mode) {
            state.executionMode = mode;
            renderUI();
        }

        function addNewWorker(isFirst = false) {
            const id = Date.now() + Math.random();
            const worker = {
                id: id,
                name: `Worker ${state.workers.length + 1}`,
                status: 'IDLE',
                targets: [],
                results: {
                    rawOutput: [],
                    metrics: {},
                    chartData: { iops: [], bw: [], latency: [] }
                },
                charts: {}
            };
            state.workers.push(worker);
            // Add a default target
            addTarget(id, true);
            // Render after adding the target
            renderUI();
        }

        function removeWorker(id) {
            if (state.workers.length <= 1 && !state.multiWorker) {
                showToast("Cannot remove the last worker", "error");
                return;
            }
            state.workers = state.workers.filter(w => w.id !== id);
            // Renumber names
            state.workers.forEach((w, idx) => w.name = `Worker ${idx + 1}`);
            renderUI();
        }

        // Target management
        function addTarget(workerId, skipRender = false) {
            const worker = state.workers.find(w => w.id === workerId);
            if (!worker) return;

            const targetId = Date.now() + Math.random();
            worker.targets.push({
                id: targetId,
                device: AVAILABLE_DEVICES.find(d => !d.disabled)?.path || '',
                block_size: '4k',
                pattern: 'random',
                read_percent: 100,
                queue_depth: 32,
                duration: 10,
                duration_unit: 'seconds'
            });
            if (!skipRender) renderUI();
        }

        function removeTarget(workerId, targetId) {
            const worker = state.workers.find(w => w.id === workerId);
            if (!worker) return;
            worker.targets = worker.targets.filter(t => t.id !== targetId);
            renderUI();
        }

        function updateTargetConfig(workerId, targetId, key, value) {
            const worker = state.workers.find(w => w.id === workerId);
            if (!worker) return;
            const target = worker.targets.find(t => t.id === targetId);
            if (!target) return;
            target[key] = value;
        }

        function resetApp() {
            state.workers = [];
            state.multiWorker = false;
            addNewWorker();

            document.getElementById('logContainer').innerHTML = "";
            renderUI();
        }

        // --- Rendering ---

        function renderUI() {
            // Destroy existing charts first to ensure no stale references to detached DOM elements
            state.workers.forEach(w => {
                if (w.charts.iops) { w.charts.iops.destroy(); w.charts.iops = null; }
                if (w.charts.bw) { w.charts.bw.destroy(); w.charts.bw = null; }
                if (w.charts.lat) { w.charts.lat.destroy(); w.charts.lat = null; }
                w.charts = {}; // Reset chart objects
            });

            const list = document.getElementById('workerList');
            list.innerHTML = '';

            state.workers.forEach(w => {

                const card = document.createElement('div');
                card.className = `worker-card ${w.status.toLowerCase()}`;

                const isRunning = w.status === 'RUNNING';

                // Build targets HTML
                let targetsHtml = '';
                w.targets.forEach((target, idx) => {
                    const deviceOpts = AVAILABLE_DEVICES.map(d => {
                        // ...
                        const disabled = d.disabled ? 'disabled' : '';
                        const icon = d.disabled ? 'üîí ' : '';
                        const title = d.disabled_reason || '';
                        return `<option value="${d.path}" ${target.device === d.path ? 'selected' : ''} ${disabled} title="${title}">${icon}${d.path} (${d.size})</option>`;
                    }).join('');

                    targetsHtml += `
                    <div class="target-card">
                        <div class="target-header">
                            <div class="target-label">Target ${idx + 1}</div>
                            <button class="btn-danger btn-sm" onclick="removeTarget(${w.id}, ${target.id})" ${isRunning ? 'disabled style="opacity:0.5; cursor:not-allowed;"' : ''}>‚úï Remove</button>
                        </div>
                        <div class="target-config-grid" ${isRunning ? 'style="pointer-events:none; opacity:0.8;"' : ''}>
                            <div class="config-item">
                                <label>Device</label>
                                <select onchange="updateTargetConfig(${w.id}, ${target.id}, 'device', this.value)">
                                    ${deviceOpts}
                                </select>
                            </div>
                            <div class="config-item">
                                <label>Block Size</label>
                                <select onchange="updateTargetConfig(${w.id}, ${target.id}, 'block_size', this.value)">
                                    <option value="4k" ${target.block_size === '4k' ? 'selected' : ''}>4 KB</option>
                                    <option value="8k" ${target.block_size === '8k' ? 'selected' : ''}>8 KB</option>
                                    <option value="16k" ${target.block_size === '16k' ? 'selected' : ''}>16 KB</option>
                                    <option value="64k" ${target.block_size === '64k' ? 'selected' : ''}>64 KB</option>
                                    <option value="1m" ${target.block_size === '1m' ? 'selected' : ''}>1 MB</option>
                                </select>
                            </div>
                            <div class="config-item">
                                <label>Pattern</label>
                                <select onchange="updateTargetConfig(${w.id}, ${target.id}, 'pattern', this.value)">
                                    <option value="random" ${target.pattern === 'random' ? 'selected' : ''}>Random</option>
                                    <option value="sequential" ${target.pattern === 'sequential' ? 'selected' : ''}>Sequential</option>
                                </select>
                            </div>
                            <div class="config-item">
                                <label>RW Mix</label>
                                <select onchange="updateTargetConfig(${w.id}, ${target.id}, 'read_percent', this.value)">
                                    <option value="100" ${target.read_percent == 100 ? 'selected' : ''}>100% Read</option>
                                    <option value="70" ${target.read_percent == 70 ? 'selected' : ''}>70R/30W</option>
                                    <option value="50" ${target.read_percent == 50 ? 'selected' : ''}>50/50 Mix</option>
                                    <option value="0" ${target.read_percent == 0 ? 'selected' : ''}>100% Write</option>
                                </select>
                            </div>
                            <div class="config-item">
                                <label>Q-Depth</label>
                                <input type="number" value="${target.queue_depth}" min="1" max="128" onchange="updateTargetConfig(${w.id}, ${target.id}, 'queue_depth', this.value)">
                            </div>
                            <div class="config-item" style="display: grid; grid-template-columns: 2fr 1fr; gap: 5px;">
                                <div>
                                    <label>Duration</label>
                                    <input type="number" value="${target.duration}" min="1" max="9999" onchange="updateTargetConfig(${w.id}, ${target.id}, 'duration', this.value)">
                                </div>
                                <div>
                                    <label>Unit</label>
                                    <select onchange="updateTargetConfig(${w.id}, ${target.id}, 'duration_unit', this.value)">
                                        <option value="seconds" ${(target.duration_unit || 'seconds') === 'seconds' ? 'selected' : ''}>Secs</option>
                                        <option value="minutes" ${target.duration_unit === 'minutes' ? 'selected' : ''}>Mins</option>
                                        <option value="hours" ${target.duration_unit === 'hours' ? 'selected' : ''}>Hrs</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                });

                // Delete button visibility
                let deleteBtn = '';
                if (state.multiWorker || state.workers.length > 1) {
                    deleteBtn = `<button class="btn-danger btn-sm" onclick="removeWorker(${w.id})" ${isRunning ? 'disabled style="opacity:0.5; cursor:not-allowed;"' : ''}>Delete</button>`;
                }

                // Build charts HTML
                const chartsHtml = `
                <div class="worker-charts-grid">
                    <div class="worker-chart-box">
                        <div class="chart-header">
                            <div class="chart-title">IOPS</div>
                            <div class="chart-value" id="val_iops_${w.id}">0</div>
                        </div>
                        <div style="flex:1; position:relative; min-height: 150px;">
                            <canvas id="chart_iops_${w.id}" width="400" height="150"></canvas>
                        </div>
                    </div>
                    <div class="worker-chart-box">
                        <div class="chart-header">
                            <div class="chart-title">Bandwidth (MB/s)</div>
                            <div class="chart-value" id="val_bw_${w.id}">0.0</div>
                        </div>
                        <div style="flex:1; position:relative; min-height: 150px;">
                            <canvas id="chart_bw_${w.id}" width="400" height="150"></canvas>
                        </div>
                    </div>
                    <div class="worker-chart-box">
                        <div class="chart-header">
                            <div class="chart-title">Latency (Œºs)</div>
                            <div class="chart-value" id="val_lat_${w.id}">0</div>
                        </div>
                        <div style="flex:1; position:relative; min-height: 150px;">
                            <canvas id="chart_lat_${w.id}" width="400" height="150"></canvas>
                        </div>
                    </div>
                </div>
                `;

                // Build final output HTML
                const hasResults = w.results.rawOutput.length > 0;
                const finalOutputHtml = hasResults ? `
                <div class="final-output-section">
                    <div class="output-header">Final Output</div>
                    <div class="metrics-summary">
                        <div class="metric-item">
                            <div class="metric-label">Avg IOPS</div>
                            <div class="metric-value">${w.results.metrics.avg_iops || 'N/A'}</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Avg BW (MB/s)</div>
                            <div class="metric-value">${w.results.metrics.avg_bw || 'N/A'}</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Avg Latency (Œºs)</div>
                            <div class="metric-value">${w.results.metrics.avg_latency || 'N/A'}</div>
                        </div>
                    </div>
                    <div class="download-controls">
                        <button class="btn-secondary btn-sm" onclick="downloadResults(${w.id}, 'csv')">üì• Download CSV</button>
                        <button class="btn-secondary btn-sm" onclick="downloadResults(${w.id}, 'json')">üì• Download JSON</button>
                    </div>
                    <div class="raw-output-box">
                        <div class="raw-output-toggle" onclick="document.getElementById('raw_${w.id}').classList.toggle('open')">
                            ‚ñ∏ Raw iobench output
                        </div>
                        <div class="raw-output-content" id="raw_${w.id}">${w.results.rawOutput.join('\n')}</div>
                    </div>
                </div>
                ` : '';

                card.innerHTML = `
                <div class="worker-header">
                    <div class="worker-title">
                         <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"/><rect x="9" y="9" width="6" height="6"/><line x1="9" y1="1" x2="9" y2="4"/><line x1="15" y1="1" x2="15" y2="4"/><line x1="9" y1="20" x2="9" y2="23"/><line x1="15" y1="20" x2="15" y2="23"/><line x1="20" y1="9" x2="23" y2="9"/><line x1="20" y1="14" x2="23" y2="14"/><line x1="1" y1="9" x2="4" y2="9"/><line x1="1" y1="14" x2="4" y2="14"/></svg>
                         ${w.name}
                         <span class="status-text ${w.status === 'RUNNING' ? 'running' : ''}">${w.status}</span>
                    </div>
                    <div style="display:flex; gap:10px;">
                        <button class="btn-secondary btn-sm" onclick="runSingleWorker(${w.id})" ${isRunning ? 'disabled style="opacity:0.5; cursor:not-allowed;"' : ''}>‚ñ∂ Run This Worker</button>
                        ${deleteBtn}
                    </div>
                </div>

                <div class="targets-container">
                    ${targetsHtml}
                    <button class="btn-secondary btn-sm" onclick="addTarget(${w.id})" style="width:fit-content;" ${isRunning ? 'disabled style="opacity:0.5; cursor:not-allowed;"' : ''}>+ Add Target</button>
                </div>

                ${chartsHtml}
                ${finalOutputHtml}
            `;
                list.appendChild(card);

                // Initialize charts for this worker
                // Defer to next tick to ensure canvas elements are in DOM
                setTimeout(() => {
                    initWorkerCharts(w);
                }, 0);
            });

            // Update Top Bar Controls
            document.getElementById('modeSingle').className = state.multiWorker ? 'toggle-btn' : 'toggle-btn active';
            document.getElementById('modeMulti').className = state.multiWorker ? 'toggle-btn active' : 'toggle-btn';

            // Toggle Stop/Run buttons based on global running state
            const anyRunning = state.workers.some(w => w.status === 'RUNNING');
            document.getElementById('btnStop').style.display = anyRunning ? 'block' : 'none';
            document.getElementById('btnRun').style.display = anyRunning ? 'none' : 'block';

            // Disable global controls if running
            if (anyRunning) {
                document.getElementById('modeSingle').disabled = true;
                document.getElementById('modeMulti').disabled = true;
                document.getElementById('btnAddWorker').disabled = true;
            } else {
                document.getElementById('modeSingle').disabled = false;
                document.getElementById('modeMulti').disabled = false;
                document.getElementById('btnAddWorker').disabled = false;
            }

            document.getElementById('execModeContainer').style.display = state.multiWorker ? 'flex' : 'none';
            document.getElementById('btnAddWorker').style.display = state.multiWorker ? 'block' : 'none';

            document.getElementById('execPar').className = state.executionMode === 'parallel' ? 'toggle-btn active' : 'toggle-btn';
            document.getElementById('execSeq').className = state.executionMode === 'sequential' ? 'toggle-btn active' : 'toggle-btn';
        }

        // --- Charts ---

        const commonChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            plugins: { legend: { display: false } },
            scales: {
                x: { display: false },
                y: { display: true, grid: { color: '#334155', drawBorder: false }, ticks: { color: '#64748b' } }
            },
            elements: { point: { radius: 0 }, line: { tension: 0.4 } }
        };

        function initWorkerCharts(worker) {
            console.log('initWorkerCharts called for worker:', worker.id);

            const canvasIOPS = document.getElementById(`chart_iops_${worker.id}`);
            const canvasBW = document.getElementById(`chart_bw_${worker.id}`);
            const canvasLat = document.getElementById(`chart_lat_${worker.id}`);

            console.log('Canvas elements:', { canvasIOPS, canvasBW, canvasLat });

            if (!canvasIOPS || !canvasBW || !canvasLat) {
                console.error('Missing canvas elements for worker', worker.id);
                return;
            }

            const ctxIOPS = canvasIOPS.getContext('2d');
            const ctxBW = canvasBW.getContext('2d');
            const ctxLat = canvasLat.getContext('2d');

            worker.charts.iops = new Chart(ctxIOPS, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#8b5cf6', backgroundColor: 'rgba(139, 92, 246, 0.1)', borderWidth: 2, fill: true }] },
                options: commonChartOptions
            });

            worker.charts.bw = new Chart(ctxBW, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.1)', borderWidth: 2, fill: true }] },
                options: commonChartOptions
            });

            worker.charts.lat = new Chart(ctxLat, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', borderWidth: 2, fill: true }] },
                options: commonChartOptions
            });

            console.log('Charts initialized for worker', worker.id);
        }

        function updateWorkerCharts(worker, iops, bw, lat) {
            if (!worker.charts.iops) return;

            if (!isNaN(iops)) {
                document.getElementById(`val_iops_${worker.id}`).innerText = Math.round(iops).toLocaleString();
                worker.charts.iops.data.labels.push("");
                worker.charts.iops.data.datasets[0].data.push(iops);
                worker.charts.iops.update();
                worker.results.chartData.iops.push(iops);
            }
            if (!isNaN(bw)) {
                document.getElementById(`val_bw_${worker.id}`).innerText = bw.toFixed(1);
                worker.charts.bw.data.labels.push("");
                worker.charts.bw.data.datasets[0].data.push(bw);
                worker.charts.bw.update();
                worker.results.chartData.bw.push(bw);
            }
            if (!isNaN(lat)) {
                document.getElementById(`val_lat_${worker.id}`).innerText = lat.toFixed(1);
                worker.charts.lat.data.labels.push("");
                worker.charts.lat.data.datasets[0].data.push(lat);
                worker.charts.lat.update();
                worker.results.chartData.latency.push(lat);
            }
        }

        // --- Execution ---

        async function runSingleWorker(id) {
            const w = state.workers.find(x => x.id === id);
            if (!w) return;

            if (w.targets.length === 0) {
                showToast(`${w.name} has no targets!`, "error");
                return;
            }

            await executeJob([w], 'parallel');
        }

        async function runJob() {
            // Validate
            if (state.multiWorker && state.executionMode === 'parallel' && state.workers.length < 2) {
                showToast("Parallel mode requires at least 2 workers", "error");
                return;
            }

            // Check targets
            for (let w of state.workers) {
                if (w.targets.length === 0) {
                    showToast(`${w.name} is missing targets`, "error");
                    return;
                }
            }

            await executeJob(state.workers, state.executionMode);
        }

        async function executeJob(workers, mode) {
            // Reset results for these workers
            workers.forEach(w => {
                w.status = 'RUNNING';
                w.results.rawOutput = [];
                w.results.metrics = {};
                w.results.chartData = { iops: [], bw: [], latency: [] };

                // Clear charts
                if (w.charts.iops) {
                    w.charts.iops.data.labels = [];
                    w.charts.iops.data.datasets[0].data = [];
                    w.charts.iops.update();
                }
                if (w.charts.bw) {
                    w.charts.bw.data.labels = [];
                    w.charts.bw.data.datasets[0].data = [];
                    w.charts.bw.update();
                }
                if (w.charts.lat) {
                    w.charts.lat.data.labels = [];
                    w.charts.lat.data.datasets[0].data = [];
                    w.charts.lat.update();
                }
            });

            renderUI();

            const jobId = Date.now().toString();
            // Start streaming
            // Note: We need to pass the FULL worker objects including targets to the backend
            // The backend expects 'workers' array in the POST body

            // Sanitize and structure payload to avoid circular references (charts) 
            // and ensure config is present for backend
            const payloadWorkers = workers.map(w => ({
                id: w.id,
                name: w.name,
                job_id: jobId,
                targets: w.targets,
                config: w.targets[0] || {} // Use first target as main config source for now
            }));

            try {
                const response = await fetch('/job', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: jobId,
                        execution_mode: mode,
                        workers: payloadWorkers
                    })
                });

                if (!response.ok) throw new Error("Failed to create job");

                // Start SSE
                // Store eventSource in state to allow aborting?
                // Actually the backend stop will kill the process, causing the stream to end or error.
                connectStream(jobId, workers);

                // Store current Job ID for abort
                state.currentJobId = jobId;

            } catch (e) {
                showToast(e.message, "error");
                runAllBtn.disabled = false;
                workerList.forEach(w => {
                    const original = state.workers.find(o => o.id === w.id);
                    if (original) original.status = 'IDLE';
                });
                renderUI();
            }
        }

        function connectStream(jobId, activeWorkers) {
            const source = new EventSource("/stream?job_id=" + jobId);

            source.onmessage = (e) => {
                if (e.data.startsWith("STATUS:")) {
                    const status = e.data.replace("STATUS:", "");
                    if (status === "Done" || status === "Error") {
                        const anyError = activeWorkers.some(w => {
                            const current = state.workers.find(cw => cw.id === w.id);
                            return current && current.status === 'ERROR';
                        });

                        activeWorkers.forEach(w => {
                            const originalW = state.workers.find(ow => ow.id === w.id);
                            if (originalW && originalW.status !== 'ERROR') {
                                originalW.status = 'IDLE';
                                calculateFinalMetrics(originalW);
                            }
                        });

                        if (anyError) {
                            showToast("Benchmark Completed with Errors", "error");
                        } else {
                            showToast("Benchmark Completed", "success");
                        }

                        renderUI();
                        // document.getElementById('runAllBtn').disabled = false;
                        source.close();
                        log(`Job Ended: ${status}`);
                    }
                    return;
                }

                try {
                    const msg = JSON.parse(e.data);

                    // Handle System messages
                    if (msg.worker_id === 'SYSTEM' || (msg.line && msg.line.startsWith('CRITICAL'))) {
                        log(`‚ùå ${msg.line}`);
                        return;
                    }

                    const worker = state.workers.find(w => w.id === msg.worker_id);

                    if (msg.line) {
                        if (worker) {
                            worker.results.rawOutput.push(msg.line);
                        }

                        if (msg.line.startsWith("CMD:")) {
                            log(`[DEBUG] ${msg.line}`);
                        } else if (msg.line.startsWith("ERROR:") || msg.line.startsWith("ERR:")) {
                            log(`‚ùå ${worker ? worker.name : ''}: ${msg.line}`);
                        } else if (msg.line.startsWith("WARN:")) {
                            log(`‚ö†Ô∏è ${worker ? worker.name : ''}: ${msg.line}`);
                        } else if (msg.line.startsWith("INF:")) {
                            const parts = msg.line.split(/\s+/);
                            if (parts.length > 6 && worker) {
                                const iops = parseFloat(parts[2]);
                                const bw = parseFloat(parts[4]);
                                const lat = parseFloat(parts[6]);
                                updateWorkerCharts(worker, iops, bw, lat);
                            }
                        }
                    }

                    if (msg.error) {
                        log(`[W${msg.worker_id}] ERROR: ${msg.error}`);
                        if (worker) {
                            worker.status = 'ERROR';
                            showToast(`Worker ${worker.name} Failed: ${msg.error}`, 'error');
                        }
                        renderUI();
                    }

                } catch (err) {
                    console.error("Parse error", err);
                }
            };

            source.onerror = () => {
                showToast("Stream Connection Lost", "error");
                source.close();
                // Check if runAllBtn exists before accessing (legacy support)
                const btn = document.getElementById('runAllBtn');
                if (btn) btn.disabled = false;
            };
        }

        function calculateFinalMetrics(worker) {
            const iopsData = worker.results.chartData.iops;
            const bwData = worker.results.chartData.bw;
            const latData = worker.results.chartData.latency;

            if (iopsData.length > 0) {
                const avg_iops = (iopsData.reduce((a, b) => a + b, 0) / iopsData.length).toFixed(0);
                worker.results.metrics.avg_iops = avg_iops;
            }
            if (bwData.length > 0) {
                const avg_bw = (bwData.reduce((a, b) => a + b, 0) / bwData.length).toFixed(1);
                worker.results.metrics.avg_bw = avg_bw;
            }
            if (latData.length > 0) {
                const avg_lat = (latData.reduce((a, b) => a + b, 0) / latData.length).toFixed(1);
                worker.results.metrics.avg_latency = avg_lat;
            }
        }

        // --- Download Results ---

        function downloadResults(workerId, format) {
            const worker = state.workers.find(w => w.id === workerId);
            if (!worker || worker.results.rawOutput.length === 0) {
                showToast("No results to download", "error");
                return;
            }

            let content, filename, mimeType;

            if (format === 'csv') {
                // CSV format: Timestamp, IOPS, BW, Latency
                const rows = ['Timestamp,IOPS,Bandwidth_MBps,Latency_us'];
                const maxLen = Math.max(
                    worker.results.chartData.iops.length,
                    worker.results.chartData.bw.length,
                    worker.results.chartData.latency.length
                );
                for (let i = 0; i < maxLen; i++) {
                    rows.push(`${i + 1},${worker.results.chartData.iops[i] || ''},${worker.results.chartData.bw[i] || ''},${worker.results.chartData.latency[i] || ''}`);
                }
                content = rows.join('\n');
                filename = `${worker.name.replace(/\s+/g, '_')}_results.csv`;
                mimeType = 'text/csv';
            } else if (format === 'json') {
                // JSON format
                const data = {
                    worker: {
                        id: worker.id,
                        name: worker.name,
                        targets: worker.targets
                    },
                    metrics: {
                        summary: worker.results.metrics,
                        timeseries: {
                            iops: worker.results.chartData.iops,
                            bandwidth: worker.results.chartData.bw,
                            latency: worker.results.chartData.latency
                        }
                    },
                    raw_output: worker.results.rawOutput.join('\n')
                };
                content = JSON.stringify(data, null, 2);
                filename = `${worker.name.replace(/\s+/g, '_')}_results.json`;
                mimeType = 'application/json';
            }

            // Trigger download
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`Downloaded ${filename}`, "success");
        }

        // --- Utils ---

        function log(msg) {
            const div = document.createElement('div');
            div.className = 'log-line';
            div.innerText = msg;
            document.getElementById('logContainer').prepend(div);
        }

        function showToast(msg, type = 'success') {
            const t = document.getElementById('toast');
            t.innerHTML = msg;
            t.className = `toast show ${type}`;
            setTimeout(() => t.className = 'toast', 3000);
        }

        init();
    </script>

</body>

</html>